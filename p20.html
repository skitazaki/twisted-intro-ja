
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>パート20: 車輪の中の車輪: Twisted と Erlang &#8212; Twisted Intro</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="パート21: おろそかにならないようにゆっくりと: Twisted と Haskell" href="p21.html" />
    <link rel="prev" title="パート19: 欲しいと思っていても考えを改めると" href="p19.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Twisted Intro</span></a></h1>
        <h2 class="heading"><span>パート20: 車輪の中の車輪: Twisted と Erlang</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="p19.html">パート19: 欲しいと思っていても考えを改めると</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="p21.html">パート21: おろそかにならないようにゆっくりと: Twisted と Haskell</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="twisted-erlang">
<h1>パート20: 車輪の中の車輪: Twisted と Erlang<a class="headerlink" href="#twisted-erlang" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>はじめに<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>この連載を通して、同期の「普通の Python」コードと非同期の Twisted のコードを混在させることは単純なことではない、ということを明らかにしてきました。
Twisted プログラムで不確定な時間のブロッキングがあると、非同期モデルを使って実現しようとしている利点の多くが失われてしまうからです。</p>
<p>今回が初めての非同期プログラミングへの入門ならば、ここまでで身に付けてきた知識はなんだか限定的であるかのように感じられるかもしれません。
Twisted の中では新しいテクニックを使えますが、もっと広い世界である一般的な Python コードでは使えません。
また、Twisted を使っていると、Twisted プログラムの一部として使うために記述されたライブラリを使うように限定されてしまいます。
少なくとも reactor を動かしているスレッドからライブラリのコードを直接呼出したい場合にはそうなります。</p>
<p>しかし非同期プログラミングのテクニックはとてもよく登場するものであり、Twisted に限ったものではありません。
実際、Python に限っても、驚くべきほどたくさんの非同期プログラミングのフレームワークがあります。
ちょっと <a class="reference external" href="http://www.google.com/search?q=python+async+frameworks">ググッてみる</a> と、それなりの数がきっと見つかるでしょう。
細かい部分では Twisted とは異なりますが、基本的な考え方 (非同期 I/O, 複数のデータストリームにまたがった小さなチャンクでのデータ処理) は一緒です。
そのため、Twisted とは異なるフレームワークを使う必要がある、もしくは選ぶなら、Twisted で学んできたことを活用できるでしょう。</p>
<p>Python 以外に目を向けてみると、非同期プログラミングモデルを基礎とした、あるいは活用するための言語やシステムがたくさんあります。
Twisted に関する知識は、この分野のさらに広大なことへの探求を手助けし続けてくれるでしょう。</p>
<p>このパートでは、 <a class="reference external" href="http://erlang.org/">Erlang</a> について目を通していきます。
Erlang は非同期プログラミングの概念をとてもよく活用したプログラミング言語でありランタイムシステムです。しかし、独特の方法です。
なお、ここでは Erlang に関する一般的な入門を意図していないことに気をつけてくださいね。
むしろ、Erlang に組み込まれた考え方についてのちょっとした探検であり、Twisted における考え方とどのようなつながりがあるかを見ていきます。
他の技術を学ぶときにも、Twisted を学ぶ中で身に付けてきた知識を適用できることが基本的なテーマです。</p>
</div>
<div class="section" id="id3">
<h2>思い出されるコールバック<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>“<a class="reference internal" href="p03.html#figure6"><span class="std std-ref">図６：reactor がコールバックを扱う様子</span></a>”を思い出してください。コールバックをグラフィカルに表現したものです。
<a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L1">Poetry Client 3.0</a> にある本質的なコールバックは、”<a class="reference internal" href="p06.html"><span class="doc">パート6: さらなる高みへ</span></a>”で導入され、それ以降のすべての詩のクライアントは <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L56">dataReceived</a> メソッドにあります。
このコールバックは、接続した詩のサーバのひとつから詩を受け取る度に呼び出されます。</p>
<p>クライアントが異なるみっつのサーバからみっつの詩をダウンロードしていると仮定しましょう。
reactor の視点から見てみると (この連載でもっとも強く協調してきた観点です)、一回りする度にひとつ以上のコールバックを生成するひとつの大きなループを持ちます。
図40を見てください。</p>
<div class="figure align-default" id="id13">
<span id="figure40"></span><img alt="_images/p20_reactor-2.png" src="_images/p20_reactor-2.png" />
<p class="caption"><span class="caption-text">図40：reactor から見たコールバック</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</div>
<p>この図は、reactor が詩を受け取ると、 <code class="docutils literal notranslate"><span class="pre">dataReceived</span></code> を呼び出しながら喜んで回り続ける様子を表します。
<code class="docutils literal notranslate"><span class="pre">dataReceived</span></code> のそれぞれの呼び出しはある特定の <code class="docutils literal notranslate"><span class="pre">PoetryProtocol</span></code> クラスのインスタンスに適用されます。
そして、みっつの詩をダウンロードしていますから、みっつのインスタンスがあります (接続もみっつあります)。</p>
<p>これらの Protocol インスタンスの「ひとつ」の観点から、この図について考えてみましょう。
それぞれのプロトコルはひとつの接続 (つまり、ひとつの詩) と一緒のことしか考えられていないことを思い出してください。
このインスタンスはメソッド呼び出しの一連の流れ (stream) を「目撃」し、それぞれのメソッドは詩の次の部分を bearing します。
こんな感じです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dataReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;When I have fears&quot;</span><span class="p">)</span>
<span class="n">dataReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot; that I may cease to be&quot;</span><span class="p">)</span>
<span class="n">dataReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Before my pen has glea&quot;</span><span class="p">)</span>
<span class="n">dataReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;n&#39;d my teeming brain&quot;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>厳密に言えばこれは実際の Python ループではありませんが、次のように概念として表現できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">poetry_stream</span><span class="p">():</span> <span class="c1"># pseudo-code</span>
    <span class="n">dataReceived</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>図41で、このコールバックループ (“callback loop”) をはっきりさせましょう。</p>
<div class="figure align-default" id="id14">
<span id="figure41"></span><img alt="_images/p20_callback-loop.png" src="_images/p20_callback-loop.png" />
<p class="caption"><span class="caption-text">図41：仮想的なコールバックのループ</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</div>
<p>繰り返しますが、これは <code class="docutils literal notranslate"><span class="pre">for</span></code> ループや <code class="docutils literal notranslate"><span class="pre">while</span></code> ループではありません。
詩のクライアントにおける重要な Python のループは reactor だけです。
しかし、それぞれのプロトコルを仮想的なループだと考えることもできます。特定の詩がやってくる度にくるくる回るのです。
この考えだと、図42のようにクライアントの全体像をもう一度想像できます。</p>
<div class="figure align-default" id="id15">
<span id="figure42"></span><img alt="_images/p20_reactor-3.png" src="_images/p20_reactor-3.png" />
<p class="caption"><span class="caption-text">図42：仮想的なループを回す reactor</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</div>
<p>この図ではひとつの大きなループ (reactor) と三つの仮想的なループ (個別の詩のプロトコルインスタンス) があります。
大きなループは回り続け、そうすることによって、連動ギアの集合のように仮想的なループを回し続けます。</p>
</div>
<div class="section" id="id4">
<h2>Erlang へ<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://erlang.org/">Erlang</a> は Python のように、汎用的な動的型付けのプログラミング言語です。元々は80年代に作られました。
Python とは異なり、Erlang はオブジェクト指向というよりは関数型で、 <a class="reference external" href="http://en.wikipedia.org/wiki/Prolog">Prolog</a> を連想させる構文を持ちます。Prolog は Erlang が元々実装された言語です。
Erlang は高い信頼性を持つ分散電話通信システムを構築するために設計されましたので、充実したネットワークサポートを持ちます。</p>
<p>Erlang の最も独特な機能のひとつは、軽量プロセスを含んだ並列モデル - concurrency model - です。
Erlang のプロセスは OS のプロセスでもスレッドでもありません。
むしろ、独自のスタックを持つ Erlang ランタイムの中で独立して動作する関数です。
Erlang のプロセスは状態を共有できません (Erlang は関数型のプログラミング言語ですから、ほとんどのデータ型は変更不可能 - immutable - です) から軽量スレッドではありません。
Erlang のプロセスはメッセージを送ることによってのみ他の Erlang プロセスとやり取りできます。
そしてメッセージはいつも、少なくとも概念的には、コピーされますが決して共有されません。</p>
<p>このため、 Erlang プログラムは図43のように見えます。</p>
<div class="figure align-default" id="id16">
<span id="figure43"></span><img alt="_images/p20_erlang-11.png" src="_images/p20_erlang-11.png" />
<p class="caption"><span class="caption-text">図43：３つのプロセスがある Erlang プログラム</span><a class="headerlink" href="#id16" title="Permalink to this image">¶</a></p>
</div>
<p>Python におけるオブジェクトのように Erlang におけるプロセスは第一級コンストラクト - first-class consutructs - ですから、この図では個別のプロセスは実際に存在 (“real”) します。
一方でランタイムは仮想的なもの (“virtual”) です。存在しないからではなく、必ずしも単純なループではないからです。
Erlang ランタイムはマルチスレッドかもしれませんし、full-blown プログラミング言語を実装できるように、非同期 I/O を扱う部分に多くの責任を持ちます。
さらに、言語のランタイムは全くもって追加コンストラクトではありません。
Twisted における reactor のように、 Erlang がプロセスとコードを実行するメディアだからです。</p>
<p>Erlang プログラムのより良い描き方は図44のようになるかもしれません。</p>
<div class="figure align-default" id="id17">
<span id="figure44"></span><img alt="_images/p20_erlang-2.png" src="_images/p20_erlang-2.png" />
<p class="caption"><span class="caption-text">図44：いくつかのプロセスがある Erlang プログラム</span><a class="headerlink" href="#id17" title="Permalink to this image">¶</a></p>
</div>
<p>もちろん Erlang ランタイムは非同期 I/O とひとつ以上の select ループを使いません。Erlang は膨大なプロセスを生成できるようにしてくれるからです。
巨大な Erlang プログラムは何十、何百、何千という Erlang プロセスを開始させますので、実際の OS スレッドにそれぞれを割り当てるなんてことは問題外です。
Erlang が複数のプロセスに入出力操作を許可し、その入出力がブロックしても他のプロセスが実行できるようなら、非同期入出力が必要になりますよね。</p>
<p>Erlang プログラムの図では、コールバックによってくるくる回っているのではなく、それぞれのプロセスが自力で (訳注: “under its own power”) 動いていることに注意してください。
ここがとても大事な部分です。
Erlang ランタイムの仕組みに組み込まれた reactor のジョブがあると、コールバックはもはや中心的な役割を持ちません。
Twisted ではコールバックを使うことによって解決された問題は、Erlang では非同期メッセージをプロセスから他のプロセスへ送信することで解決します。</p>
</div>
<div class="section" id="id5">
<h2>Erlang による詩のクライアント<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Erlang による詩のクライアントを見ていきましょう。
Twisted でやってきたようにゆっくりと構築していくのではなく、一気に動くバージョンを扱います。
繰り返しになりますが、これは完全な Erlang 入門を意図していません。
とはいえ、このエントリが興味をそそるなら、このパートの終わりでもっと深く学ぶために読むべき書籍を紹介します。</p>
<p>Erlang のクライアントは <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L1">erlang-client-1/get-poetry</a> にあります。
実行させるためには、もちろん <a class="reference external" href="http://erlang.org/">Erlang</a> をインストールする必要があります。
<a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L96">main</a> 関数のコードはこのようになります。
これは、 Python クライアントでの main 関数と似た目的を果たします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="p">([])</span> <span class="o">-&gt;</span>
    <span class="n">usage</span><span class="p">();</span>

<span class="n">main</span><span class="p">(</span><span class="n">Args</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">Addresses</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">(</span><span class="n">Args</span><span class="p">),</span>
    <span class="n">Main</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(),</span>
    <span class="p">[</span><span class="n">erlang</span><span class="p">:</span><span class="n">spawn_monitor</span><span class="p">(</span><span class="n">fun</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">get_poetry</span><span class="p">(</span><span class="n">TaskNum</span><span class="p">,</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">Main</span><span class="p">)</span> <span class="n">end</span><span class="p">)</span>
     <span class="o">||</span> <span class="p">{</span><span class="n">TaskNum</span><span class="p">,</span> <span class="n">Addr</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Addresses</span><span class="p">)],</span>
    <span class="n">collect_poems</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">Addresses</span><span class="p">),</span> <span class="p">[])</span><span class="o">.</span>
</pre></div>
</div>
<p>これまでに Prolog かそれと似たような言語を見たことがないと、 Erlang の構文はちょっと奇妙に見えるかもしれません。
しかし、Python について同じように言う人もいます。
メイン関数は、セミコロンによって分割されたふたつの clauses によって定義されています。
Erlang は引数マッチによって動かすべき clause を選びますので、最初の clause はコマンドライン引数を与えることなくクライアントを起動したときのみ実行され、ヘルプメッセージを出力します。
ふたつ目の clause がアクションの中心となります。</p>
<p>Erlang の関数における独立した文はコンマで分割され、すべての関数はピリオドで終わります。
ふたつ目の clause におけるそれぞれの行を順番にみていきましょう。
１行目はコマンドライン引数を処理し、その結果を変数に束縛します (Erlang における全ての変数は大文字から始めなくてはいけません - capitalized)。
２行目は、 現在実行中の Erlang プロセス (OS のプロセスではありません) のプロセス ID を取得するために、Erlang の <code class="docutils literal notranslate"><span class="pre">self</span></code> 関数を使っています。
これがメイン関数ですから、Python での <code class="docutils literal notranslate"><span class="pre">__main__</span></code> モジュールと同じものだと考えてください。
３行目はもっとも興味深いですね。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">erlang</span><span class="p">:</span><span class="n">spawn_monitor</span><span class="p">(</span><span class="n">fun</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">get_poetry</span><span class="p">(</span><span class="n">TaskNum</span><span class="p">,</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">Main</span><span class="p">)</span> <span class="n">end</span><span class="p">)</span>
     <span class="o">||</span> <span class="p">{</span><span class="n">TaskNum</span><span class="p">,</span> <span class="n">Addr</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Addresses</span><span class="p">)],</span>
</pre></div>
</div>
<p>この statement は Erlang のリスト内包表記 - list comprehension - で、Python での構文に似ています。
新しい Erlang プロセスを spawning します。このプロセスは、接続する必要のある詩のサーバのそれぞれになります。
それぞれのプロセスは同じ関数 (<code class="docutils literal notranslate"><span class="pre">get_poetry</span></code>) を実行するでしょうが、サーバに固有の引数は別々です。
新しいプロセスが詩を送り返せるように (一般的にプロセスにメッセージを送るためには、その PID が必要になります)、メインプロセスの PID も渡します。</p>
<p><code class="docutils literal notranslate"><span class="pre">main</span></code> の最後の一文で <code class="docutils literal notranslate"><span class="pre">collect_poems</span></code> 関数を呼び出します。この関数は詩がやってくることと <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> プロセスが終了することを待ちます。
他の関数についてももう少し見ていきますが、まずは Erlang の
<a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L96">main</a> 関数と、Twisted クライアントで <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-4/get-poetry.py#L96">等価な main</a> 関数を比べてみましょうか。</p>
<p>それでは Erlang の <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> 関数に目を通していきましょう。
<code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> というスクリプトには実際にはふたつの関数があります。
Erlang では、関数は名前と arity の両方で識別されますので、スクリプトはふたつの別々の関数を含みます。
それぞれ三つと四つの引数を受け付ける <code class="docutils literal notranslate"><span class="pre">get_poetry/3</span></code> と <code class="docutils literal notranslate"><span class="pre">get_poetry/4</span></code> です。
<a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L79">get_poetry/3</a> は次のようになり、 <code class="docutils literal notranslate"><span class="pre">main</span></code> によって spawn されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">get_poetry</span><span class="p">(</span><span class="n">Tasknum</span><span class="p">,</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">Main</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">Host</span><span class="p">,</span> <span class="n">Port</span><span class="p">}</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">,</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="n">Socket</span><span class="p">}</span> <span class="o">=</span> <span class="n">gen_tcp</span><span class="p">:</span><span class="n">connect</span><span class="p">(</span><span class="n">Host</span><span class="p">,</span> <span class="n">Port</span><span class="p">,</span>
                                   <span class="p">[</span><span class="n">binary</span><span class="p">,</span> <span class="p">{</span><span class="n">active</span><span class="p">,</span> <span class="n">false</span><span class="p">},</span> <span class="p">{</span><span class="n">packet</span><span class="p">,</span> <span class="mi">0</span><span class="p">}]),</span>
    <span class="n">get_poetry</span><span class="p">(</span><span class="n">Tasknum</span><span class="p">,</span> <span class="n">Socket</span><span class="p">,</span> <span class="n">Main</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span>
</pre></div>
</div>
<p>この関数は、Twisted クライアントの <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> と同じように、まずは TCP 接続を生成します。
しかし、そこで処理を戻すのではなく、 <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L85">get_poetry/4</a> を呼び出すことでその TCP 接続を使い続けます。
<code class="docutils literal notranslate"><span class="pre">get_poetry/4</span></code> は次の通りです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>get_poetry(Tasknum, Socket, Main, Packets) -&gt;
    case gen_tcp:recv(Socket, 0) of
        {ok, Packet} -&gt;
            io:format(&quot;Task ~w: got ~w bytes of poetry from ~s\n&quot;,
                      [Tasknum, size(Packet), peername(Socket)]),
            get_poetry(Tasknum, Socket, Main, [Packet|Packets]);
        {error, _} -&gt;
            Main ! {poem, list_to_binary(lists:reverse(Packets))}
    end.
</pre></div>
</div>
<p>この Erlang 関数は Twisted クライアントでは <code class="docutils literal notranslate"><span class="pre">PoetryProtocol</span></code> が果たしていたことをやっています。Twisted 版ではブロックする関数呼び出しを使いますが、Erlang 版はそうではありません。
<code class="docutils literal notranslate"><span class="pre">gen_tcp:recv</span></code> 関数はソケットへのデータ到着 (もしくはソケットが閉じられること) を待ち受けます。どれだけ長くなろうとも。
しかし、Erlang での “blocking” 関数は、関数を実行しているプロセスをブロックするだけで、Erlang ランタイム全体をブロックするわけではありません。
この TCP ソケットは本当はブロックしているソケットではありません (ピュア Erlang コードでは、真にブロックするソケットを生成できません)。
こうしたそれぞれの Erlang ソケットのために、Erlang ランタイムの中のどこかに、ノンブロッキングモードに設定された「本物の」TCP ソケットがあり、select ループの一部として使われます。</p>
<p>しかし、Erlang プロセスこれらに関して何も知りません。
ただただデータが届くのを待ち、もしもブロックするなら、他の Erlang プロセスが動くことになります。
プロセスは決してブロックしなくとも、Erlang ランタイムはいつでも実行プロセスを自由に切り替えられます。
言い換えると、Erlang は 非協調並行モデル - non-cooperative concurrency model - を持ちます。</p>
<p>詩の一部を受け取った後に、 <code class="docutils literal notranslate"><span class="pre">get_poetry/4</span></code> が再帰的に自分自身を呼び出して実行することに注意しましょう。
imperative な言語のプログラマにとっては、メモリを使い果たしてしまう (out of memory) レシピのように見えるかもしれませんね。
しかし Erlang コンパイラーは末尾呼び出し (“tail” calls - 関数の最後にある関数呼び出し) をループに最適化できます。
このことは、Erlang と Twisted クライアントの間に横たわるもうひとつの興味深い点をハイライトしてくれます。
Twisted クライアントでは、reactor が何度も繰り返し同じ関数 (<code class="docutils literal notranslate"><span class="pre">dataReceived</span></code>) を呼び出すことによって “virtual” ループが生成されました。
Erlang クライアントでは、 <a class="reference external" href="http://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail-call optimization</a> を使って、自分自身 (<code class="docutils literal notranslate"><span class="pre">themselves</span></code>) を繰り返し呼び出すことによって実行中の “real” プロセス (<code class="docutils literal notranslate"><span class="pre">get_poetry/4</span></code>) がループを形成します。
どうでしょうか。</p>
<p>接続が閉じられると、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> が最後にすべきはメインプロセスへの詩の送信です。
また、それ以上にすべきことが何もなくなるように、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> が実行しているプロセスを終了させます。</p>
<p>Erlang クライアントで残る主要な関数は、 <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L58">collect_poems</a> です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">collect_poems</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Poems</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="n">io</span><span class="p">:</span><span class="nb">format</span><span class="p">(</span><span class="s2">&quot;~s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">P</span><span class="p">])</span> <span class="o">||</span> <span class="n">P</span> <span class="o">&lt;-</span> <span class="n">Poems</span><span class="p">];</span>
<span class="n">collect_poems</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Poems</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">receive</span>
        <span class="p">{</span><span class="s1">&#39;DOWN&#39;</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="n">collect_poems</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Poems</span><span class="p">);</span>
        <span class="p">{</span><span class="n">poem</span><span class="p">,</span> <span class="n">Poem</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="n">collect_poems</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">[</span><span class="n">Poem</span><span class="o">|</span><span class="n">Poems</span><span class="p">])</span>
    <span class="n">end</span><span class="o">.</span>
</pre></div>
</div>
<p>この関数はメインプロセスによって実行され、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> のように、自分自身を再帰的にループします。
またブロックもします。
<code class="docutils literal notranslate"><span class="pre">receive</span></code> 文は与えられたパターンにマッチするメッセージが届くのを待つようにプロセスに伝えます。
受け取ったら「メールボックス」 (“mailbox”) からメッセージを展開します。</p>
<p><code class="docutils literal notranslate"><span class="pre">collect_poems</span></code> 関数は二種類のメッセージを待ちます。詩と “DOWN” 通知です。
後者は、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> プロセスのひとつが何らかの理由で死んでしまったときにメインプロセスに送信されるメッセージです (これは <code class="docutils literal notranslate"><span class="pre">spawn_monitor</span></code> の一部である <code class="docutils literal notranslate"><span class="pre">monitor</span></code> です)。
<code class="docutils literal notranslate"><span class="pre">DOWN</span></code> メッセージを数えることによって、全ての詩を受け取ることが完了したときが分かります。
前者は、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> プロセスのひとつからのひとつの完全な詩を含んでいるメッセージです。</p>
<p>よし、Erlang クライアントを動かしてみましょう。
まずはゆっくりした詩のサーバ (slow poetry server) を三つ立ち上げます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">blocking</span><span class="o">-</span><span class="n">server</span><span class="o">/</span><span class="n">slowpoetry</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">port</span> <span class="mi">10001</span> <span class="n">poetry</span><span class="o">/</span><span class="n">fascination</span><span class="o">.</span><span class="n">txt</span>
<span class="n">python</span> <span class="n">blocking</span><span class="o">-</span><span class="n">server</span><span class="o">/</span><span class="n">slowpoetry</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">port</span> <span class="mi">10002</span> <span class="n">poetry</span><span class="o">/</span><span class="n">science</span><span class="o">.</span><span class="n">txt</span>
<span class="n">python</span> <span class="n">blocking</span><span class="o">-</span><span class="n">server</span><span class="o">/</span><span class="n">slowpoetry</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">port</span> <span class="mi">10003</span> <span class="n">poetry</span><span class="o">/</span><span class="n">ecstasy</span><span class="o">.</span><span class="n">txt</span> <span class="o">--</span><span class="n">num</span><span class="o">-</span><span class="nb">bytes</span> <span class="mi">30</span>
</pre></div>
</div>
<p>ようやく Erlang クライアントを実行できます。これは Python クライアントと似たコマンドライン構文を持ちます。
Linux か UNIX-like なシステムならクライアントを直接実行できます (Erlang がインストールされていて、 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> が有効だと仮定しています)。
Windows ではおそらく、Erlang クライアントへのパスを最初の引数として (残りは Erlang クライアント自身への引数です)、 <code class="docutils literal notranslate"><span class="pre">escript</span></code> プログラムを実行する必要があるでしょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">erlang</span><span class="o">-</span><span class="n">client</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">poetry</span> <span class="mi">10001</span> <span class="mi">10002</span> <span class="mi">10003</span>
</pre></div>
</div>
<p>実行させてみるとこのような出力が見えるはずです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="mi">3</span><span class="p">:</span> <span class="n">got</span> <span class="mi">30</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">poetry</span> <span class="kn">from</span> <span class="mi">127</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">10003</span>
<span class="n">Task</span> <span class="mi">2</span><span class="p">:</span> <span class="n">got</span> <span class="mi">10</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">poetry</span> <span class="kn">from</span> <span class="mi">127</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">10002</span>
<span class="n">Task</span> <span class="mi">1</span><span class="p">:</span> <span class="n">got</span> <span class="mi">10</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">poetry</span> <span class="kn">from</span> <span class="mi">127</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">10001</span>
<span class="o">...</span>
</pre></div>
</div>
<p>これは以前の Python クライアントの出力そのものです。受け取った詩の断片を出力させます。
すべての詩を受け取ると、クライアントはそれぞれの完全な文字列を出力するでしょう。
クライアントは、送信すべき詩が存在するか否かに従って全てのサーバに対して接続をあちこちと切り替えていることに注意しましょう。</p>
<p>図45は Erlang クライアントのプロセス構造を図示してくれます。</p>
<div class="figure align-default" id="id18">
<span id="figure45"></span><img alt="_images/p20_erlang-3.png" src="_images/p20_erlang-3.png" />
<p class="caption"><span class="caption-text">図45：Erlang での詩のクライアント</span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></p>
</div>
<p>この図はみっつの <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> プロセス (サーバごとにひとつです) と、ひとつのメインプロセスを表します。
詩のプロセスからメインプロセスへ流れるメッセージも見えますね。</p>
<p>それでは、これらのサーバのひとつがダウンしたら何が起こるでしょうか？
やってみましょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">erlang</span><span class="o">-</span><span class="n">client</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">poetry</span> <span class="mi">10001</span> <span class="mi">10005</span>
</pre></div>
</div>
<p>上のコマンドは有効なポート (前述の詩のサーバは全て動作し続けていると仮定) と有効でないポート (10005番ポートを使っているサーバは存在しないと仮定) を含みます。
すると、このような出力が見られますね。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Task</span> <span class="mi">1</span><span class="p">:</span> <span class="n">got</span> <span class="mi">10</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">poetry</span> <span class="kn">from</span> <span class="mi">127</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">10001</span>

<span class="o">=</span><span class="n">ERROR</span> <span class="n">REPORT</span><span class="o">====</span> <span class="mi">25</span><span class="o">-</span><span class="n">Sep</span><span class="o">-</span><span class="mi">2010</span><span class="p">::</span><span class="mi">21</span><span class="p">:</span><span class="mi">02</span><span class="p">:</span><span class="mi">10</span> <span class="o">===</span>
<span class="n">Error</span> <span class="ow">in</span> <span class="n">process</span> <span class="o">&lt;</span><span class="mf">0.33</span><span class="o">.</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">with</span> <span class="n">exit</span> <span class="n">value</span><span class="p">:</span> <span class="p">{{</span><span class="n">badmatch</span><span class="p">,{</span><span class="n">error</span><span class="p">,</span><span class="n">econnrefused</span><span class="p">}},[{</span><span class="n">erl_eval</span><span class="p">,</span><span class="n">expr</span><span class="p">,</span><span class="mi">3</span><span class="p">}]}</span>

<span class="n">Task</span> <span class="mi">1</span><span class="p">:</span> <span class="n">got</span> <span class="mi">10</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">poetry</span> <span class="kn">from</span> <span class="mi">127</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">10001</span>
<span class="n">Task</span> <span class="mi">1</span><span class="p">:</span> <span class="n">got</span> <span class="mi">10</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">poetry</span> <span class="kn">from</span> <span class="mi">127</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">10001</span>
<span class="o">...</span>
</pre></div>
</div>
<p>時折、クライアントはアクティブなサーバから詩をダウンロードし終えて、詩を出力してから終了します。
それでは、 <code class="docutils literal notranslate"><span class="pre">main</span></code> 関数が両方のプロセスが完了したことを知っていたらどうなるでしょうか？
そのエラーメッセージが clue です。
<code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> がサーバへの接続を試みて、期待する値 (<code class="docutils literal notranslate"><span class="pre">{ok,</span> <span class="pre">Socket}</span></code>) ではなく接続拒否のエラーを受け取ったときに、このエラーが発生します。
Erlang の “assignment” 文は実際にはパターンマッチ操作であるため、結果となる例外は <code class="docutils literal notranslate"><span class="pre">badmatch</span></code> と呼ばれます。</p>
<p>Erlang プロセス内で処理されていない例外はプロセスをクラッシュさせます。
これは、プロセスが停止し、そのプロセスに関する全てのリソースが回収 - garbage collected - されたことを意味します。
しかし、これらのプロセスが何らかの理由で動作を終了したら、 <code class="docutils literal notranslate"><span class="pre">main</span></code> プロセス、これはすべての <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> プロセスを監視しています、は <code class="docutils literal notranslate"><span class="pre">DOWN</span></code> メッセージを受け取るでしょう。
というわけで、クライアントは永遠に実行を続けるのではなく、終了します。</p>
</div>
<div class="section" id="id8">
<h2>議論<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Twisted と Erlang クライアントの間にある共通項を押さえておきましょう。</p>
<ul class="simple">
<li><p>どちらのクライアントも一度に全ての詩のサーバに接続 (あるいは接続しようと) します。</p></li>
<li><p>どちらのクライアントも、どのサーバが運んできたかに関わらず、データがやってくるとすぐに受け取ります。</p></li>
<li><p>どちらのクライアントも少しずつ詩を処理しますので、そこまでに受け取ってきた詩の断片を保存しておく必要があります。</p></li>
<li><p>どちらのクライアントも、ある特定のサーバに対するすべての仕事を処理するために、”object” (Python オブジェクトか Erlang プロセスのどちらか) を生成します。</p></li>
<li><p>どちらのクライアントも、特定のダウンロードが成功したか失敗したかに関わらず、全ての詩を処理し終えたときを注意深く決定しなくてはなりません。</p></li>
</ul>
<p>最後に、どちらのクライアントでも <code class="docutils literal notranslate"><span class="pre">main</span></code> 関数は非同期に詩とタスク完了 (“task done”) 通知を受信します。
Twisted クライアントでは、この情報は <code class="docutils literal notranslate"><span class="pre">Deferred</span></code> によって伝達されます。一方、 Erlang クライアントはプロセス間でメッセージを受け取ります。</p>
<p>戦略全体とコード構造の両方において、両方のクライアントにどれほどの類似点があるかに注意しましょう。
一方ではオブジェクト、遅延オブジェクト、それからコールバックを使い、もう一方ではプロセスとメッセージを使いますので、メカニズムはちょっと違います。
しかし、高レベルでのメンタルモデルはとても似ています。
双方に慣れ親しんでしまえば、どちらかからもう一方に移動するのはとても簡単なことでしょう。</p>
<p>Erlang クライアントでは reactor パターンでさえ非常に小型化された形式で再度出現します。
詩のクライアントにおけるそれぞれの Erlang プロセスは時々再帰的なループになります。</p>
<ul class="simple">
<li><p>何かが起きることを待ち (詩の断片が届く、とか、詩が転送される、とか、もうひとつのプロセスが完了する、など)、</p></li>
<li><p>いくつかの適切なアクションを実行します。</p></li>
</ul>
<p>Erlang プログラムを、小さな reactor がたくさん集まったものだと考えることもできます。
それぞれが spinning し、時々小さな reactor にメッセージを送るのです (他のイベントと同じようにそのメッセージを処理するでしょう)。</p>
<p>もしも Erlang についてより深く学ぼうと思ったら、コールバックを見える化しましょう。
Erlang の <a class="reference external" href="http://www.erlang.org/doc/man/gen_server.html">gen_server</a> プロセスは、固定数のコールバック関数を提供することによってインスタンス化 (“instantiate”) する、汎用的な reactor ループです。
これは、Erlang システムのそこここで繰り返し現れるパターンです。</p>
<p>Twisted を学んだ後で、もしも Erlang をやってみようと思ったなら、慣れ親しんだメンタルテリトリー (familiar mental territory) にあると気付くでしょう。</p>
</div>
<div class="section" id="id9">
<h2>さらに読むべきもの<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>このパートでは、Twisted と Erlang で共通したことに焦点を当ててきました。しかしもちろん、違う部分もたくさんあります。
Erlang 独特の機能として、エラー処理のアプローチがあります。
巨大な Erlang プログラムは、上位の枝分かれ (higher branches) にスーパーバイザー (“supervisors”) を持ち、葉にワーカー (“workers”) を持つ、プロセスの木として構成されます。
もしもワーカープロセスがクラッシュすると、スーパーバイザープロセスが気付き、いくつかのアクションを引き継ぐでしょう (典型的には、失敗したワーカーを再起動させます)。</p>
<p>Erlang についてもっと学習したくなったらツイテますね。
いくつかの Erlang 本が最近になって出版されたか、まもなく出版 (<a class="footnote-reference brackets" href="#id11" id="id10">1</a>) されます。</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.amazon.com/exec/obidos/ASIN/193435600X/krondonet-20">Programming Erlang</a> —
Erlang 開発者のひとりによって書かれた書籍です。言語への素晴らしい入門編です。</p></li>
<li><p><a class="reference external" href="http://www.amazon.com/exec/obidos/ASIN/0596518188/krondonet-20">Erlang Programming</a> —
Armstrong の書籍を補完し、いくつかの主要な領域についてより深く記述されています。</p></li>
<li><p><a class="reference external" href="http://www.amazon.com/exec/obidos/ASIN/1933988789/krondonet-20">Erlang and OTP in Action</a> —
この書籍はまだ発売されていませんが、手元に届くのが待ちきれません。
上のふたつの本は OTP には言及していません。OTP は Erlang  で大きなアプリケーションを構築するためのフレームワークです。
ちなみに、著者のふたりは私の友達です。</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id10">1</a></span></dt>
<dd><p>2010年12月に出版されました。</p>
</dd>
</dl>
<p>Erlang に関してはこのくらいにしておきましょう。
“<a class="reference internal" href="p21.html"><span class="doc">パート21: おろそかにならないようにゆっくりと: Twisted と Haskell</span></a>” では Haskell を見ていきます。Python とも Erlang とも大いに異なる雰囲気を持つ、もうひとつの関数型言語です。
言うまでもありませんが、いくつかの共通点を見出していくことになるでしょう。</p>
<div class="section" id="id12">
<h3>おすすめの練習問題<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Erlang と Python クライアントを見比べてみて、似ている部分と異なる部分を見分けましょう。
どのようにエラー (詩のサーバに接続失敗したように) を処理しているでしょうか？</p></li>
<li><p>受信した詩の部分部分を出力しないように Erlang クライアントを単純化してください (タスク番号を追跡する必要もありませんね)。</p></li>
<li><p>それぞれの詩をダウンロードする時間を計測するように Erlang クライアントを修正してください。</p></li>
<li><p>コマンドラインで与えられた順番と同じ順番で詩を出力するように Erlang クライアントを修正してください。</p></li>
<li><p>詩のサーバに接続できないときに、もっと可読性の高いエラーメッセージを表示するよう Erlang クライアントを修正してください。</p></li>
<li><p>Twisted を使って実装した詩のサーバの Erlang バージョンを記述してください。</p></li>
</ol>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="p19.html">パート19: 欲しいと思っていても考えを改めると</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="p21.html">パート21: おろそかにならないようにゆっくりと: Twisted と Haskell</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2010, Shigeru Kitazaki.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>