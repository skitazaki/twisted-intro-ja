
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>パート6: さらなる高みへ &#8212; Twisted Intro</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="パート7: Deferred 入門" href="p07.html" />
    <link rel="prev" title="パート5: もっと Twisted の詩を" href="p05.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Twisted Intro</span></a></h1>
        <h2 class="heading"><span>パート6: さらなる高みへ</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="p05.html">パート5: もっと Twisted の詩を</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="p07.html">パート7: Deferred 入門</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="id1">
<h1>パート6: さらなる高みへ<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>みんなの詩<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>詩のクライアントを大きく進歩させてきました。最新のバージョン (2.0) は Transports と Protocols、それに Protocol Factories という Twisted ネットワーキングの中でも核となる部分を使っています。しかし、またまだ改良の余地はあります。クライアント 2.0 (2.1 もそうです) はコマンドラインで詩をダウンロードすることにしか使えません。 <code class="docutils literal notranslate"><span class="pre">PoetryClientFactory</span></code> が詩を取得するだけでなく、それが終わったときにプログラムを終了させることも受け持っているからです。”<code class="docutils literal notranslate"><span class="pre">PoetryClientFactory</span></code>” と呼ばれるものには不釣り合いな仕事であり、 <code class="docutils literal notranslate"><span class="pre">PoetryProtocol</span></code> を生成してダウンロード済みの詩をまとめる以外の何事もすべきではありません。</p>
<p>まずは、詩を要求するコードに詩を送る方法が必要です。同期プログラムでは、こんな感じの API にするでしょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">post</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the text of a poem from the poetry server at the given host and port.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>しかし当然ではありますがこんな風にはできません。上の関数では詩を完全に受け取るまでブロックする必要性があります。でないとドキュメントで述べているようには動きません。とはいえこれは reactive プログラムです。ネットワークソケットにおけるブロッキングは問題とはなりませんので。私たちには、詩が転送されている間はブロッキングすることなく、詩の準備ができたら呼び出し元のコードに知らせる方法が必要です。これは Twisted 自身に持っていて欲しい類の問題です。Twisted は私たちのコードに次のタイミングで知らせる必要があります。ソケットが入出力の準備できたとき、もしくは何らかのデータを受信したとき、それともタイムアウトが発生したとき、などなどです。Twisted がコールバックを使ってこの問題を解決してくれることを見てきました。ですから、私たちだって同じようにコールバックを使えます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a poem from the given host and port and invoke</span>

<span class="sd">      callback(poem)</span>

<span class="sd">    when the poem is complete.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>今は Twisted で使える非同期 API も手に入れましたので、先に進んでこれを実装してみましょう。</p>
<blockquote>
<div><p>以前にも述べたように、私たちは時として、一般的な Twisted プログラマーはやらないような方法でコードを書いていきます。これはそんなものの一種です。
パート７と８で “Twisted なやり方” (なんと抽象化を使うのです！) での実装を見ることになります。しかし、簡単なことから始めると、完成形に対するより深い洞察を得られるでしょう。</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h2>クライアント 3.0<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>バージョン 3.0 のクライアントは <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py">twisted-client-3/get-poetry.py</a> にあります。このバージョンには <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L77">関数</a> の実装があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">reactor</span>
    <span class="n">factory</span> <span class="o">=</span> <span class="n">PoetryClientFactory</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
    <span class="n">reactor</span><span class="o">.</span><span class="n">connectTCP</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">factory</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで新しく着目する唯一のことは <code class="docutils literal notranslate"><span class="pre">PoetryClientFactory</span></code> にコールバック関数を渡していることです。 <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L66">ファクトリ</a> は詩を提供するためにコールバックを使います。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PoetryClientFactory</span><span class="p">(</span><span class="n">ClientFactory</span><span class="p">):</span>

    <span class="n">protocol</span> <span class="o">=</span> <span class="n">PoetryProtocol</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>

    <span class="k">def</span> <span class="nf">poem_finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poem</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">poem</span><span class="p">)</span>
</pre></div>
</div>
<p>ファクトリは reactor を終了させる責任を負いませんので、バージョン 2.1 のものに比べてはるかに簡単になっていますね。接続に失敗したことを検知するコードもなくなっていますが、ちょっと手直しするつもりです。クライアントのバージョン 2.1 からその機能を再利用するだけですので、 <code class="docutils literal notranslate"><span class="pre">PoetryProtocol</span></code> 自身を変更する必要は全くありません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PoetryProtocol</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>

    <span class="n">poem</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">dataReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poem</span> <span class="o">+=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">connectionLost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poemReceived</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poem</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">poemReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poem</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">poem_finished</span><span class="p">(</span><span class="n">poem</span><span class="p">)</span>
</pre></div>
</div>
<p>この変更によって、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> 関数と <code class="docutils literal notranslate"><span class="pre">PoetryClientFactory</span></code> および <code class="docutils literal notranslate"><span class="pre">PoetryProtocol</span></code> クラスは完全に再利用可能なものになりました。詩をダウンロードするだけのものであり、他のことは何もしません。reactor を起動、終了させる全てのロジックは <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L90">main 関数</a> にあります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">poetry_main</span><span class="p">():</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>

    <span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">reactor</span>

    <span class="n">poems</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">got_poem</span><span class="p">(</span><span class="n">poem</span><span class="p">):</span>
        <span class="n">poems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poem</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poems</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">addresses</span><span class="p">):</span>
            <span class="n">reactor</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">addresses</span><span class="p">:</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">address</span>
        <span class="n">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">got_poem</span><span class="p">)</span>

    <span class="n">reactor</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">poem</span> <span class="ow">in</span> <span class="n">poems</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">poem</span>
</pre></div>
</div>
<p>要求通りに、再利用可能な部品を手にすることができ、誰もが詩を取得するために使えるように共有モジュールに配置できますね (もちろん、Twisted を使っている限り、ですけど)。</p>
<p>ところで、実際にクライアント 3.0 をテストしてみると、詩をより早く送信するようにしたり、より大きなデータの塊にして送信するなど、詩のサーバを再構成したくなるかもしれません。クライアントは余計な出力をしないようになりましたので、詩をダウンロードする間のことを監視してもそれほど興味深くはありません。</p>
<p>議論
—
図１１のように、詩が提供される時点でのコールバックチェーンを視覚化できます。</p>
<div class="figure align-default" id="id10">
<span id="figure11"></span><img alt="_images/p06_reactor-poem-callback.png" src="_images/p06_reactor-poem-callback.png" />
<p class="caption"><span class="caption-text">図１１：詩のコールバック</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>図１１には説明の必要がありますね。これまでは、「自分たちのコード」を呼び出して終了するようにコールバックチェーンを説明してきました。しかし、Twisted を使うかシングルスレッドの reactive システムのプログラムを書くときは、これらのコールバックチェーンは他の部分のコードを呼び出させるようにして私たちのコードを取り込むかもしれません。言い換えると、reactive スタイルのプログラミングは、私たち自身が記述したコードに到達しても止まりません。reactor ベースのシステムではコールバックは進んでいくだけなのです。</p>
<p>プロジェクトで Twisted を使うときにはこのことを念頭においてください。こう決心したときは、</p>
<blockquote>
<div><p>Twisted を使うぞ！</p>
</div></blockquote>
<p>この決定もしたことになります。</p>
<blockquote>
<div><p>reactor ループに基づいた一連の非同期コールバックチェーンの呼び出しとしてプログラムを構築していこう！</p>
</div></blockquote>
<p>別に声に出して宣言することでもありませんが、同じことです。それが Twisted のやり方ですから。</p>
<p>たいていの Python プログラムは同期して動きますし、Python のモジュールもそうです。同期プログラムを書いていればすぐに次のことに気付きます。詩を受け取るために必要なのは、同期バージョンの <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> 関数に以下の数行のコードを追加して使うことでしょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">import</span> <span class="nn">poetrylib</span> <span class="c1"># モジュールに名前を付けました (I just made this module name up)</span>
<span class="n">poem</span> <span class="o">=</span> <span class="n">poetrylib</span><span class="o">.</span><span class="n">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>それでは私たちのやり方を続けていきましょう。後になってもしも、実は詩を欲しくなんてなかった、と思ったらこの数行を取り除けばよいだけです。困ることもないでしょう。しかし、同期プログラムを書いていて <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> の Twisted バージョンを使うと決めたなら、プログラムをコールバックを使った非同期なスタイルで再構築しなくてはならなくなります。おそらくコードに大きな変更をしなくてはいけないでしょう。プログラムを書き直すような間違いが必要だと言っているわけではありません。要件が与えられれば意味のあることでしょう。しかし、 <code class="docutils literal notranslate"><span class="pre">import</span></code> の行といくつかの関数呼び出しを追加するほどには簡単ではないでしょう。同期と非同期のコードは混在させられません。</p>
<p>Twisted と非同期プログラミングに慣れていないなら、既存のコードベースを移植する前にスクラッチから Twisted のプログラムをいくつか書いてみることをお勧めします。移植しながら一度に両方のモードで考えようとする余計な複雑さがなくなり、Twisted を使うことにも安心できるでしょう。</p>
<blockquote>
<div><p>けれども、あなたのプログラムがすでに非同期なら、Twisted を使うことははるかに簡単かもしれません。
Twisted は比較的スムーズに <a class="reference external" href="http://pygtk.org/">pyGTK</a> と <a class="reference external" href="http://wiki.python.org/moin/PyQt">pyQT</a> に繋げられます。
これらは reactor ベースの GUI ツールキットのための Python API です。</p>
</div></blockquote>
</div>
<div class="section" id="id6">
<h2>おかしくなってしまうとき<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>クライアント 3.0 では、接続に失敗したことを検出しなくなりました。クライアント 1.0 で省略したときよりもいくぶんの問題を引き起こすようになりました。クライアント 3.0 に存在しないサーバから詩をダウンロードさせてみると、クラッシュすることなく永遠に待ち続けます。それでも <code class="docutils literal notranslate"><span class="pre">clientConnectionFailed</span></code> コールバックは呼び出されますので、基底クラス <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/internet/protocol.py#L103">ClientFactory</a> にある標準実装は全く何もしません。このため、 <code class="docutils literal notranslate"><span class="pre">get_poem</span></code> コールバックが呼ばれることはありませんし、reactor は止まりません。”<a class="reference internal" href="p02.html"><span class="doc">パート2: ゆったりした詩と世紀末</span></a>”で作ったような何もしないプログラムになります。</p>
<p>明らかにこのエラーをなんとかする必要があります。どこで？接続に失敗したという情報は <code class="docutils literal notranslate"><span class="pre">clientConnectionFailed</span></code> を介してファクトリ・オブジェクトにもたらされます。ということで、そこから始めることになります。しかし、このファクトリは再利用可能なものと考えられていますし、エラーを処理する適切な方法は、ファクトリが利用されるコンテキストに依存します。いくつかのアプリケーションでは、詩を見失ってしまうと甚大な被害になるかもしれません (詩が無いって？クラッシュみたいなものかもね)。他の場合では、そのまま動作を続けてどこか違うところからもう一つの詩を受け取るようにするかもしれません。</p>
<p>言い換えると、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> のユーザは、正常に動いているときではなく、おかしくなってしまったときを知る必要があるのです。同期プログラムでは、 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> が <code class="docutils literal notranslate"><span class="pre">Exception</span></code> を発生させ、呼び出すコードはそれを <code class="docutils literal notranslate"><span class="pre">try/except</span></code> 構文で処理できるようにするでしょう。しかし、reactive プログラムでは、エラー状態も非同期にもたらされます。 <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> 関数が処理を返す後まで、私たちは接続に失敗したことさえ分からないのです。</p>
<p>一つの可能性を見せましょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a poem from the given host and port and invoke</span>

<span class="sd">      callback(poem)</span>

<span class="sd">    when the poem is complete. If there is a failure, invoke:</span>

<span class="sd">      callback(None)</span>

<span class="sd">    instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>コールバックの引数をテストする (つまり <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">poem</span> <span class="pre">is</span> <span class="pre">None</span></code> ) ことによって、クライアントは私たちが詩を受け取ったかどうかを確定できます。クライアントが延々と実行し続けることは避けられますが、この方法にはまだいくつかの問題点があります。何よりもまず、失敗を示すのに <code class="docutils literal notranslate"><span class="pre">None</span></code> を使うのはその場しのぎ過ぎます。次に、 <code class="docutils literal notranslate"><span class="pre">None</span></code> という値では非常に限定された情報しか渡せません。何が悪かったのか分かりません。ここでは、デバッグに使えるようにトレースバック・オブジェクトを含めてあげましょう。では二つ目です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a poem from the given host and port and invoke</span>

<span class="sd">      callback(poem)</span>

<span class="sd">    when the poem is complete. If there is a failure, invoke:</span>

<span class="sd">      callback(err)</span>

<span class="sd">    instead, where err is an Exception instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Exception</span></code> を使うと同期プログラミングで使ったものに近くなりますね。これで何が悪かったかは例外を見ればよくなり、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を通常の値としても使えるようになります。通常は、Python で例外に出会ったときはトレースバックも取得し、後でデバッグするために解析したりログに書き出したりします。トレースバックは本当に便利です。非同期プログラミングだからといって諦めるべきではありません。</p>
<p>コールバックが呼び出された場所で出力するためにトレースバック・オブジェクトを必要としているわけではありませんよ。そこは問題が起こった場所ではありません。私たちが本当に欲しいのは、 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> インスタンスとその例外が送出された場所からのコールバックの両方です (単に生成された場所ではなく、送出された場所です)。</p>
<p>Twisted には <code class="docutils literal notranslate"><span class="pre">Exception</span></code> とトレースバックの両方を包括する <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/python/failure.py#L121">Failure</a> という抽象化があります。 <code class="docutils literal notranslate"><span class="pre">Failure</span></code> の <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/python/failure.py#L141">docstring</a> で作り方を説明しています。 <code class="docutils literal notranslate"><span class="pre">Failure</span></code> オブジェクトをコールバックに渡すことで、デバッグに便利なトレースバック情報を保存できます。</p>
<p><a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-failure/failure-examples.py">twisted-failure/failure-examples.py</a> には <code class="docutils literal notranslate"><span class="pre">Failure</span></code> オブジェクトを使うコード例がいくつかあります。これを見れば、 <code class="docutils literal notranslate"><span class="pre">Failure</span></code> が送出された例外からのトレースバック情報を保存する方法が分かるでしょう。たとえ <code class="docutils literal notranslate"><span class="pre">except</span></code> ブロックの外側のコンテキストだったとしてもです。 <code class="docutils literal notranslate"><span class="pre">Failure</span></code> インスタンスを作ることに多くを語る気はありません。パート７では、Twisted がそれを生成してくれるのが分かるでしょう。</p>
<p>それでは三つ目です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a poem from the given host and port and invoke</span>

<span class="sd">      callback(poem)</span>

<span class="sd">    when the poem is complete. If there is a failure, invoke:</span>

<span class="sd">      callback(err)</span>

<span class="sd">    instead, where err is a twisted.python.failure.Failure instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>このバージョンでは、うまく動かないときには <code class="docutils literal notranslate"><span class="pre">Exception</span></code> とトレースバックの両方を取得できます。いいですね！</p>
<p>もう一息のところですが、もうひとつ問題点があります。通常の結果と失敗の両方に対して同じコールバックを使うのはちょっと変ですね。一般的に、失敗に対しては成功に対する場合と全く異なる対処が必要です。同期版の Python プログラムでは <code class="docutils literal notranslate"><span class="pre">try/catch</span></code> の中で成功と失敗を異なるコードで扱います。こんな風に。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">attempt_to_do_something_with_poetry</span><span class="p">()</span>
<span class="k">except</span> <span class="n">RhymeSchemeViolation</span><span class="p">:</span>
    <span class="c1"># the code path when things go wrong</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># the code path when things go so, so right baby</span>
</pre></div>
</div>
<p>エラー処理でこの形式を保ちたいなら、失敗に対しては分離したコードの進み方にさせる必要があります。非同期プログラミングでは、コードの進み方が分離されていることはコールバックが分離されていることを意味します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_poetry</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">errback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a poem from the given host and port and invoke</span>

<span class="sd">      callback(poem)</span>

<span class="sd">    when the poem is complete. If there is a failure, invoke:</span>

<span class="sd">      errback(err)</span>

<span class="sd">    instead, where err is a twisted.python.failure.Failure instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>クライアント 3.1<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>今度は妥当なエラー処理の意味を持つ API を使えますので、あとはそれを実装します。クライアント 3.1 は <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry-1.py">twisted-client-3/get-poetry-1.py</a> にあります。変更点はここまでの内容そのままです。 <a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry-1.py#L66">PoetryClientFactory</a> は <code class="docutils literal notranslate"><span class="pre">callback</span></code> と <code class="docutils literal notranslate"><span class="pre">errback</span></code> の両方を受け取り、  <code class="docutils literal notranslate"><span class="pre">clientConnectionFailed</span></code> を実装します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PoetryClientFactory</span><span class="p">(</span><span class="n">ClientFactory</span><span class="p">):</span>

    <span class="n">protocol</span> <span class="o">=</span> <span class="n">PoetryProtocol</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">errback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errback</span> <span class="o">=</span> <span class="n">errback</span>

    <span class="k">def</span> <span class="nf">poem_finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poem</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">poem</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clientConnectionFailed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errback</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/internet/protocol.py#L118">clientConnectionFailed</a> は接続に失敗した理由を説明する <code class="docutils literal notranslate"><span class="pre">Failure</span></code> オブジェクト (<code class="docutils literal notranslate"><span class="pre">reason</span></code> 引数) を受け取るようにすでになっていますので、 <code class="docutils literal notranslate"><span class="pre">errback</span></code> に渡すだけです。</p>
<p>他の変更はすべて小さなものなので、ここでは示しません。クライアント 3.1 は次のようにサーバ名を付けずにポート番号を指定してテストできます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">twisted</span><span class="o">-</span><span class="n">client</span><span class="o">-</span><span class="mi">3</span><span class="o">/</span><span class="n">get</span><span class="o">-</span><span class="n">poetry</span><span class="o">-</span><span class="mf">1.</span><span class="n">py</span> <span class="mi">10004</span>
</pre></div>
</div>
<p>次のような結果を目にするでしょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poem</span> <span class="n">failed</span><span class="p">:</span> <span class="p">[</span><span class="n">Failure</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Traceback</span> <span class="p">(</span><span class="n">failure</span> <span class="k">with</span> <span class="n">no</span> <span class="n">frames</span><span class="p">):</span> <span class="p">:</span>
 <span class="n">Connection</span> <span class="n">was</span> <span class="n">refused</span> <span class="n">by</span> <span class="n">other</span> <span class="n">side</span><span class="p">:</span> <span class="mi">111</span><span class="p">:</span> <span class="n">Connection</span> <span class="n">refused</span><span class="o">.</span><span class="p">]</span>
</pre></div>
</div>
<p><a class="reference external" href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry-1.py#L110">poem_failed</a> の <code class="docutils literal notranslate"><span class="pre">print</span></code> 文からの出力です。Twisted は <code class="docutils literal notranslate"><span class="pre">Exception</span></code> を送出するのではなく、単に渡すだけです。このため、ここではトレースバックはありません。しかし、巨大ではないからトレースバックは実際には必要とされません。Twisted は私たちに知らせてくれただけです。正確に、そのアドレスには接続できない、と</p>
</div>
<div class="section" id="id8">
<h2>まとめ<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>パート６で学んだのは次のことです。</p>
<ul class="simple">
<li><p>Twisted プログラムのために書いた API は非同期でなくてはなりません。</p></li>
<li><p>非同期なコードに同期のコードを混ぜることはできません。</p></li>
<li><p>したがって、私たち自身のコードでもコールバックを使わなくてはなりません。Twisted がそうしているように。</p></li>
<li><p>そして、エラーを処理するのもコールバックでなくてはなりません。</p></li>
</ul>
<p>Twisted を使って記述するどの API においても、追加で二つの引数、通常のコールバックとエラー用のコールバック、を含めなくてはならないのでしょうか？そんなに良いことには思えません。幸運にも Twisted は、私たちがどちらも使わなくても済み、おまけに追加でいくつかの機能を持たせてくれる抽象化を持ちます。これについては”<a class="reference internal" href="p07.html"><span class="doc">パート7: Deferred 入門</span></a>”で学んでいきましょう。</p>
</div>
<div class="section" id="id9">
<h2>おすすめの練習問題<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>指定された時間が経過しても詩を受信しなければタイムアウトするようにクライアント 3.1 を修正しましょう。このような場合は独自の例外でエラー用コールバックを呼び出してください。接続を閉じるのも忘れないように。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Failure</span></code> オブジェクトの <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/python/failure.py#L278">trap</a> メソッドを学習してください。
<code class="docutils literal notranslate"><span class="pre">trap</span></code> と <code class="docutils literal notranslate"><span class="pre">try/except</span></code> 文の <code class="docutils literal notranslate"><span class="pre">except</span></code> 節を比べてください。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clientConnectionFailed</span></code> は <code class="docutils literal notranslate"><span class="pre">get_poetry</span></code> が処理を返した後に呼ばれていることを検証するために <code class="docutils literal notranslate"><span class="pre">print</span></code> 文を使ってください。</p></li>
</ol>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="p05.html">パート5: もっと Twisted の詩を</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="p07.html">パート7: Deferred 入門</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2010, Shigeru Kitazaki.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>